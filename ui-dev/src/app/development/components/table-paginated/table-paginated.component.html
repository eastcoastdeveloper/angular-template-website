<div id="table-component" class="element-shadow">
  <div class="table-details">
    <span>Popular Muscle Cars</span>
    <span *ngIf="cars.length > 0" class="total-items"
      >{{ cars.length }} items</span
    >
    <div class="search-box">
      <input
        [(ngModel)]="enteredSearchValue"
        (keyup)="applyFilter(enteredSearchValue)"
        placeholder="Search a make or model"
      />
    </div>
  </div>
  <table>
    <thead>
      <tr>
        <th class="pl-15">Year</th>
        <th>Make</th>
        <th>Model</th>
      </tr>
    </thead>
    <tbody>
      <tr
        *ngFor="
          let car of cars | paginate : { itemsPerPage: 8, currentPage: p }
        "
      >
        <td class="pl-15">{{ car.year }}</td>
        <td>{{ car.make }}</td>
        <td>{{ car.model }}</td>
      </tr>
    </tbody>
  </table>
  <div class="pagination">
    <pagination-controls (pageChange)="p = $event"></pagination-controls>
  </div>
</div>

<p class="project-text element-margin-top">
  Creating an Angular data table can be daunting if you're not sure where to
  begin. Check out the code below to get you up and running quick! As most
  everything these days is powered by endpoints, this example uses JSON mock
  data to emulate a response. Please see the below JSON.
</p>

<h2>Data and Interface</h2>
<div class="code-preview">
  <pre><code>{{json}}</code></pre>
</div>

<p class="project-text element-margin-top">
  Create a representation of the data via an interface. This is in essence an
  object blueprint. Used to express the necessary keys. Enforced at runtime, not
  upon transpilation.
</p>

<div class="code-preview element-margin-top">
  <pre><code>{{interface}}</code></pre>
</div>

<h2>Angular Data Table TypeScript</h2>
<ul class="project-list">
  <li>Create an array for the incoming data.</li>
  <li>Apply the CarsResponse data type.</li>
  <li>p is indicative of the current paginated page.</li>
  <li>Reference the httpClient in the constructor then request the data.</li>
  <li>
    tableDataReq() fetches the response with the usual observable suspects of
    next, error, and complete.
  </li>
  <li>Subscribe to retrieve the request and set it to the cars array.</li>
  <li>The pipe method is used to contain sequentially executed methods.</li>
  <li>
    tap() passes values to the oberserver, but also has the ability to perform
    independent operations. Suppose you want to push modified values to an
    array. We could display those modified values as well as the original
    values. For this reason, it's often used for logging purposes. But, we all
    know, there are unique situations when we'd need to perform atypical tasks.
  </li>
</ul>

<div class="code-preview element-margin-top">
  <pre><code>{{typescript}}</code></pre>
</div>

<h2>Create the UI</h2>
<p class="project-text">
  Loop over the cars array populating year, make, and model. Set the number of
  items per page followed by the current page. Please note however, using let i
  = index in the index loop does not successfully track the index. Indices are
  reset every page. To circumvent this, you could of course add the index to the
  JSON or extrapolate the indice from the backend. Perhaps a more succinct
  method would be to use the afforementioned i var, then simply multiple it by
  the current page.
</p>

<div class="code-preview element-margin-top">
  <pre><code>{{markup}}</code></pre>
</div>

<h2>Beautify it with SCSS</h2>
<p class="project-text">
  Beyond the nesting, the only real anomolies here are the use of ::ng-deep.
  This unique selector is oftentimes frowned upon. Possibly because it's used
  the wrong way in my opinion. I use it specifically to override third party
  library styles. These are classes that cannot be captured before rendering.
  The selector is used in the shadow DOM&mdash;a process using encapsulation
  when creating elements.
</p>

<p class="project-text element-margin-top">
  The drawback of using ::ng-deep is it disables this encapsulation process. In
  turn making the class global. Moreover, it has unexpected results with lazy
  loaded modules. Regardless, it seems to be virtually impossible to override
  third party library styles without it.
</p>

<div class="code-preview element-margin-top">
  <pre><code>{{styling}}</code></pre>
</div>

<h2>In Closing</h2>
<p class="project-text">
  There's an infinite of ways to accomplish pagination. I've used this method
  many times over though in a variety of projects. It's always straightforward,
  flexible, and easy to customize. If you're met with a challenge at any point,
  check out the
  <span class="attention-arrow">&#x2190;</span>
  <span class="external-link" (click)="navigateToPage(urlStackblitz)"
    >Angular Data Table Stackblitz demo.</span
  >. Thanks for reading. Have a great day!
</p>
