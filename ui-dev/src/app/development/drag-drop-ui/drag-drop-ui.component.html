<p class="project-text">
  Not long ago I was tasked with creating a complex JavaScript drag and drop UI.
  One in which gave users the ability to move MULTIPLE items at once. This was a
  feature I'd never done prior. And this was a project I was the lead frontend
  developer for. Additionally, the client was the United States Senate. Not only
  would members of Congress be using a UI I created, but every mouse or hand
  gesture was a POST request.
</p>

<p class="project-text element-margin-top">
  Most of which is irrelevant. I'm a developer, and therefore need to ensure
  that whatever I build works flawlessly. Regardless of the client. I wanted to
  be 100% prepared for the upcoming task. In turn, I created this UI. Though far
  from exact, it demonstrates creative drag abilities via JSON content.
  <span class="attention-arrow">&#x2190;</span>
  <span class="external-link" (click)="navigateToPage(urlStackblitz)"
    >Working demo here.</span
  >
  Code analysis below.
</p>

<div class="element-shadow image-wrapper element-margin-top">
  <img
    [src]="dragDropImage"
    alt="Grey background with a complex interface indicative of dragging and dropping elements from a list to a group."
  />
</div>

<h2>JavaScript Drag and Drop</h2>
<p class="project-text">
  Yes, techically this is TypeScript. But because I originally wrote it in
  JavaScript, and there's lot's of it here, I'm gonna say JavaScript. I digress.
  The point of this is to explore a draggable UI without a library. See how it's
  working, and maybe get new ideas for a project you're working on.
</p>

<p class="project-text element-margin-top">
  In retrospect, I'd avoid using innerHTML. It's certainly inbuilt and
  oftentimes useful, but I've read from numerous resources how it's a
  vulnerability. Yes, deterministic of how it's used, but I now avoid it
  entirely.
</p>

<ul class="project-list element-margin-top">
  <li>
    items is an array of objects. Later down it's used like so:
    {{ snippetOne }}. This is a group reference. If we created two directories
    named colors and cities, items would look like this: {{ snippetTwo }}.
  </li>
  <li>
    groupItem is the same thing, but for a new group item. In the event we'd
    like to add a new value to the UI. A value we'd like to then drag somewhere.
    Enter something in that field, and it'll appear as list value to be dragged.
  </li>
  <li>
    groupIndex on the other hand is the unsortedItems array indice. Picking up
    Honda would make the groupIndex 1. Dragging Orange, groupIndex is 0.
    Dragging blue, groupIndex is 3.
  </li>
  <li>result holds the incoming JSON data.</li>
  <li>
    uploadedCount signifies how the elements are currently "uploaded". Afterall,
    this JavaScript drag and drop is a mock file uploader. This array contains
    references to the elements in each "directory".
  </li>
  <li>itemTitle is the value: {{ snippetThree }} shows how it's being used.</li>
  <li>
    itemName is a value that's captured from the template via ngModel. It's a
    banana in a boat [()] meaning two way data binding. In turn, when a value's
    entered in the 'Add Group Name' field, it flows to the model.
  </li>
  <li>
    addNewItem is an array of list category references. {{ snippetFour }}. These
    are the lists of draggable items. When they're being dragged, they become
    {{ snippetFive }}
  </li>
  <li>
    itemIndex helps to determine which named item was moved from the items
    array.
  </li>
  <li>
    namedElements is an array of HTML elements housed in each "directory".
  </li>
  <li>
    directoryElements is an array of "directory" drop zones. When we drag,
    directoryElements sends up a flag saying, "hey, these are the available drop
    zones."
  </li>
  <li>draggedItem is the raw text of the current item being dragged.</li>
  <li>draggedElement is the HTML element in full.</li>
</ul>

<div class="code-preview element-margin-top">
  <pre><code>{{typescript}}</code></pre>
</div>

<h2>Bring it All Together</h2>

<p class="project-text">
  There's no way around it. If you're creating a UI like this without a library,
  it's gonna be complex. Plus, factoring in POST requests at every drop like my
  project called for&mdash;not fun. Though many would advocate using a library,
  I try to avoid using libs whenever possible. Why? I find lots of feature based
  libraries to be more problematic than helpful simply because every project is
  unique. And using one creates boundaries. In turn, I need to fight the feature
  to have it act the way the project calls for.
</p>

<p class="project-text element-margin-top">
  Such is the case with a draggable plugin. You'll spend more time trying to get
  the lib to mimic the intended behavior vs creating a system of your own. At
  the end of the day, you've got a flexible system. One in which you know what
  every line is doing.
</p>

<div class="code-preview">
  <pre><code>{{markup}}</code></pre>
</div>

<p class="project-text element-margin-top">
  This could no doubt be improved with more specified data types, but time was
  of the essence when I built a low-fi mock. One in which to emulate an actual
  feature in a proprietary application. If you need a working version of this
  JavaScript drag and drop UI, see the demo
  <span class="attention-arrow">&#x2190;</span>
  <span class="external-link" (click)="navigateToPage(urlStackblitz)">here</span
  >.
</p>
